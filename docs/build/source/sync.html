<!DOCTYPE html>

<html>
<head>
  <title>sync.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>sync.coffee</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h3>Backbone.HookSync</h3>
<p>This file provides a function, <code>make</code> for building a new
sync function for your Backbone.Model which will call the methods
you define.  It is particularily useful for integrating Backbone
with the JavaScript API interface of your choice.</p>
<p>The basic idea:</p>
<pre><code>class MyAwesomeModel extends Backbone.Model
  sync: Backbone.HookSync.make
    create: myAwesomeCreator
    update: &#39;create&#39;
    delete: &#39;default&#39;
    read: 
      do: myAwesomeReader
      build: (method, model, options) -&gt;
        model.attributes</code></pre>
<p>The file also provides two functions to add a new sync method to
your existing classes.</p>
<p><code>bind</code> adds the method to an existing class:</p>
<pre><code>class MyAwesomeModel extends Backbone.Model
  # Model Dets Here

Backbone.HookSync.bind MyAwesomeModel,
  create: newCreator

  # Reads, Updates and Deletes will continue to use the
  # models sync, or if one is not defined, Backbone.Sync</code></pre>
<p><code>wrap</code> returns a new copy of your class with the sync method replaced:</p>
<pre><code>class MyAwesomeModel extends Backbone.Model
  # Some Modeling..

MoreAwesomeModel = Backbone.HookSync.wrap MyAwesomeModel,
  update: _.noop</code></pre>
<h4>Options</h4>
<p>All three methods expect an object containing 1-4 of the CRUD methods:</p>
<ul>
<li>create</li>
<li>read</li>
<li>update</li>
<li>delete</li>
</ul>
<p>Optionally, a <code>sync</code> method which will be used with requests which
do not match one of the provided methods (or for methods defined as
&#39;default&#39;).</p>
<p>Optionally, a <code>defaults</code> object which provides defaults to the four
CRUD methods.</p>
<p>Each of the CRUD method keys can have any of the following values:</p>
<ul>
<li>A function (to do the action)</li>
<li>A string referring to another CRUD method who&#39;s value should be used</li>
<li>&#39;default&#39;, <code>null</code>, or <code>undefined</code> representing the default sync behavior</li>
<li>An object</li>
</ul>
<p>If an object is used it can have the following attributes:
 - <code>function do</code> - The function to be called (make sure you use string notation [&quot;do&quot;] if
          you&#39;re not writing CoffeeScript)
 - <code>function build(method, model, options)</code> - A function used to build the request passed
          into do.  Defaults to <code>model.toJSON()</code>.
 - <code>boolean expandArguments[false]</code> - Should the array returned by <code>build</code> be
          expanded and passed into do as seperate arguments?
 - <code>boolean returnsPromise[false]</code> - Does do return a Deferred object?  If so
          it&#39;s done and fail methods will trigger the success and error
          callbacks (and the default callbacks will be disabled).
 - <code>boolean addOptions[true]</code> - Should the options hash be merged in with
          the return value of build?</p>
<p>If you&#39;re using expandArguments, addOptions: false is implied.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> module? <span class="keyword">and</span> <span class="keyword">not</span> window?.module?
    _ = require(<span class="string">'underscore'</span>)
    Backbone = require(<span class="string">'backbone'</span>)

  CRUD = [<span class="string">'create'</span>, <span class="string">'read'</span>, <span class="string">'update'</span>, <span class="string">'delete'</span>]

  HANDLER_DEFAULTS =
    addOptions: <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Returns a copy of the class with sync extended by the handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">wrap</span></span> = (cls, handlers) -&gt;
    nCls = cls
    nCls:: = _.clone cls::

    bind nCls, handlers

    nCls</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Mutates an existing class to replace sync with a new sync
method powered by the handlers.</p>
<p>Preserves a reference to the existing sync, so any method
not handled will fall through to the original.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">bind</span></span> = (cls, handlers) -&gt;
    <span class="keyword">if</span> cls::sync</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>make knows to look at handlers.sync if the sync method
is not bound in the handlers (or is bound as &#39;default&#39;).</p>
<p>If there is no cls::sync (the default case for Backbone), 
make will use Backbone.sync.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      handlers.sync ?= cls::sync

    cls::sync = make handlers
    
    cls</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Build a sync function compatable with Backbone out of one or more
CRUD functions.  Anything you don&#39;t override will get passed through
to the default sync function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">make</span></span> = (handlers) -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Handlers is a map of CRUD methods to the functions which should
handle them + some other options.</p>
<p>Replace all of the string handler pointers with
the actual handlers they point to.  Replace &#39;default&#39;
with null</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    resolveHandlers handlers</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Normalize the handler to always be an object with a 
make method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    handlersToObjects handlers</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><code>handlers.defaults</code> can contain default options for
all of the handlers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    applyDefaults handlers</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>This is the sync-replacement we&#39;ll be returning</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    (method, model, options) -&gt;
      handler = handlers[method]

      <span class="keyword">if</span> handler
        request = buildRequest handler, method, model, options

        makeRequest handler, request, model, options

      <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>This method is most likely gonna be overriding the
model&#39;s sync method, so calling @sync would recurse, so
we let the fall-through sync be passed in as an option.</p>
<p><code>wrap</code> and <code>bind</code> do this for you, automatically preserving the
previous sync in handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        (handlers.sync <span class="keyword">or</span> Backbone.sync) method, model, options</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>In this context, a request is the object which will be passed
into the <code>do</code> function passed in as a handler.  Based on the
<code>expandArguments</code> property, it can either be a single object,
or an array of arguments.</p>
<p>Unless you set handler.addOptions to false, the options object will be
automatically merged with the attributes your return.</p>
<p>The build function defaults to <code>model.toJSON</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">buildRequest</span></span> = (handler, method, model, options) -&gt;
    builder = handler.build ? model.toJSON
    
    req = builder.call model, method, model, options

    <span class="keyword">if</span> handler.addOptions <span class="keyword">and</span> <span class="keyword">not</span> handler.expandArguments
      req = _.extend {}, options, req

    req</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Do it!</p>
<p>handler.returnsPromise gives you a convenient way to
convert a method which normally returns a promise to
work with Backbone&#39;s success and error handlers.</p>
<p>It will replace the passed-in success and error handlers
with noops so they are not called twice.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">makeRequest</span></span> = (handler, request, model, options) -&gt;
    <span class="keyword">if</span> handler.returnsPromise
      oldOptions = _.pick request, <span class="string">'success'</span>, <span class="string">'error'</span>
      request.success = request.<span class="function"><span class="title">error</span></span> = -&gt;

    <span class="keyword">if</span> handler.expandArguments
      resp = handler.<span class="keyword">do</span> request...
    <span class="keyword">else</span>
      resp = handler.<span class="keyword">do</span> request, model, options
     
    <span class="keyword">if</span> handler.returnsPromise
      resp.done (data) -&gt;
        callSuccessCallback(model, data, options, oldOptions)
        model.trigger(<span class="string">'sync'</span>, model, resp, options)

      resp.fail (err) -&gt;
        oldOptions.error? err
        model.trigger(<span class="string">'error'</span>, err, model, options)</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>After Backbone 0.9.2, the fetch success wrapper Backbone
creates changed the arguments supplied by the callback.</p>
<p>While this isn&#39;t ideal, it&#39;s nice to be backwards compatible
to 0.9.2.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">callSuccessCallback</span></span> = (model, data, options, oldOptions) -&gt;
    <span class="keyword">if</span> isBackboneVersionGreaterThan(<span class="string">'0.9.2'</span>) <span class="keyword">and</span> <span class="keyword">not</span> isBackboneVersionGreaterThan(<span class="string">'0.9.10'</span>)
      oldOptions.success? model, data, options
    <span class="keyword">else</span>
      oldOptions.success? data</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Handler can be passed in as either functions, or
objects which have some more options and functions.
To make it easier, lets make them objects all of the time.</p>
<p>It modifies the passed in object in-place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">handlersToObjects</span></span> = (handlers) -&gt;
    <span class="keyword">for</span> type, handler <span class="keyword">of</span> handlers <span class="keyword">when</span> type <span class="keyword">in</span> CRUD
      <span class="keyword">if</span> _.isFunction handler
        handlers[type] =
          <span class="keyword">do</span>: handler</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Use handlers.defaults as the defaults for all of the other
handlers.</p>
<p>Modifies the passed-in object in-place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">applyDefaults</span></span> = (handlers) -&gt;
    <span class="keyword">for</span> type, handler <span class="keyword">of</span> handlers <span class="keyword">when</span> type <span class="keyword">in</span> CRUD
      handlers[type] = _.extend {}, HANDLER_DEFAULTS, handlers.defaults, handler</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Handlers can be string references to the keys of other handlers,
or &#39;default&#39;.</p>
<p>Modifies the passed in object in-place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">resolveHandlers</span></span> = (handlers) -&gt;
    <span class="keyword">for</span> type, handler <span class="keyword">of</span> handlers <span class="keyword">when</span> type <span class="keyword">in</span> CRUD
      <span class="keyword">switch</span> handler
        <span class="keyword">when</span> <span class="string">'default'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>In this context, <code>default</code> means pass request through to
<code>handlers.sync</code> or <code>Backbone.sync</code>.</p>
<p>For convenience, normalize default to be falsy
as we also support simply skipping the handler type to
signify &#39;default&#39;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          handlers[type] = <span class="literal">null</span>
        <span class="keyword">when</span> <span class="string">'create'</span>, <span class="string">'update'</span>, <span class="string">'read'</span>, <span class="string">'delete'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>You can alias the handler to another handler.</p>
<p>The most common usage of this is to map create to the same thing
as update, e.g.:</p>
<pre><code>make
  create: myHandler
  update: &#39;create&#39;</code></pre>
<p>This is only going to reliably work to one level of depth,
you can&#39;t reference references.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          handlers[type] = handlers[handler]

  <span class="function"><span class="title">isBackboneVersionGreaterThan</span></span> = (compare) -&gt;
    comparison = compare.split(<span class="string">'.'</span>)
    current = Backbone.VERSION.split(<span class="string">'.'</span>)

    parseInt(comparison[<span class="number">0</span>]) &lt; parseInt(current[<span class="number">0</span>]) <span class="keyword">or</span>
    parseInt(comparison[<span class="number">1</span>]) &lt; parseInt(current[<span class="number">1</span>]) <span class="keyword">or</span>
    parseInt(comparison[<span class="number">2</span>]) &lt; parseInt(current[<span class="number">2</span>])

  exports = {make, wrap, bind}
  Backbone?.HookSync = exports

  module?.exports = exports</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
